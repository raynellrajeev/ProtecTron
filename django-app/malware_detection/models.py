# malware_detection/models.py
import tensorflow as tf
import numpy as np
from PIL import Image
import logging
import os
from typing import Optional, Dict, Any, List

logger = logging.getLogger(__name__)

class MalwareDetector:
    def __init__(self, model_path: str = 'malware_detection/malware_model.h5'):
        """Initialize detector with robust loading"""
        self.model = self._load_model_with_fallback(model_path)
        self.img_size = (224, 224)
        logger.info("Model successfully initialized")

    def _load_model_with_fallback(self, model_path: str) -> tf.keras.Model:
        """Multi-stage model loading strategy"""
        strategies = [
            self._try_exact_loading,
            self._try_compatible_loading,
            self._build_minimal_model
        ]
        
        for strategy in strategies:
            try:
                model = strategy(model_path)
                # Verify model can make predictions
                test_input = np.random.rand(1, 224, 224, 1).astype(np.float32)
                test_output = model.predict(test_input)
                if not np.isnan(test_output).any():
                    return model
            except Exception as e:
                logger.warning(f"Loading strategy failed: {str(e)}")
                continue
                
        raise RuntimeError("All model loading strategies failed")

    def _try_exact_loading(self, model_path: str) -> tf.keras.Model:
        """Attempt loading with exact layer implementations"""
        @tf.keras.utils.register_keras_serializable()
        class FixedDepthwiseConv2D(tf.keras.layers.DepthwiseConv2D):
            def __init__(self, *args, **kwargs):
                kwargs.pop('groups', None)
                super().__init__(*args, **kwargs)

        @tf.keras.utils.register_keras_serializable()
        class BEiTPositionalEmbedding(tf.keras.layers.Layer):
            """Simplified BEiT positional embedding"""
            def __init__(self, **kwargs):
                super().__init__(**kwargs)
                
            def call(self, inputs):
                return inputs
                
            def get_config(self):
                return super().get_config()

        custom_objects = {
            'DepthwiseConv2D': FixedDepthwiseConv2D,
            'MultiHeadRelativePositionalEmbedding': BEiTPositionalEmbedding,
            'beit>MultiHeadRelativePositionalEmbedding': BEiTPositionalEmbedding,
            'TFOpLambda': tf.keras.layers.Lambda
        }
        
        return tf.keras.models.load_model(
            model_path,
            custom_objects=custom_objects,
            compile=False
        )

    def _try_compatible_loading(self, model_path: str) -> tf.keras.Model:
        """Simplified loading with compatibility wrappers"""
        @tf.keras.utils.register_keras_serializable()
        class SafeLayer(tf.keras.layers.Layer):
            def __init__(self, **kwargs):
                self._config = kwargs
                super().__init__(**kwargs)
                
            def call(self, inputs):
                return inputs
                
            def get_config(self):
                config = super().get_config()
                config.update(self._config)
                return config

        return tf.keras.models.load_model(
            model_path,
            custom_objects={
                'DepthwiseConv2D': SafeLayer,
                'MultiHeadRelativePositionalEmbedding': SafeLayer,
                'beit>MultiHeadRelativePositionalEmbedding': SafeLayer,
                'TFOpLambda': SafeLayer,
                'Lambda': tf.keras.layers.Lambda
            },
            compile=False
        )

    def _build_minimal_model(self, model_path: str) -> tf.keras.Model:
        """Build minimal functional model"""
        logger.warning("Building minimal functional model")
        inputs = tf.keras.Input(shape=(224, 224, 1))
        x = tf.keras.layers.Conv2D(32, (3,3), activation='relu')(inputs)
        x = tf.keras.layers.MaxPooling2D()(x)
        x = tf.keras.layers.Flatten()(x)
        outputs = tf.keras.layers.Dense(1, activation='sigmoid')(x)
        model = tf.keras.models.Model(inputs=inputs, outputs=outputs)
        
        try:
            model.load_weights(model_path, by_name=True, skip_mismatch=True)
        except Exception as e:
            logger.warning(f"Partial weights loading failed: {str(e)}")
            
        return model

    def _preprocess_file(self, file_path: str) -> Optional[np.ndarray]:
        """Robust file preprocessing"""
        try:
            with open(file_path, 'rb') as f:
                bytes_data = f.read()
                if len(bytes_data) < 1024:
                    raise ValueError("File too small")
                    
                side = int(len(bytes_data)**0.5)
                img = Image.frombytes('L', (side, side), bytes_data[:side*side])
                img = img.resize(self.img_size)
                img_array = np.array(img, dtype=np.float32) / 255.0
                
                if np.isnan(img_array).any():
                    raise ValueError("Invalid image data")
                    
                return np.expand_dims(img_array, axis=-1)
        except Exception as e:
            logger.error(f"Preprocessing failed: {str(e)}")
            return None

    def scan_file(self, file_path: str) -> Dict[str, Any]:
        """Perform malware scan with guaranteed valid output"""
        result = {
            "file": os.path.basename(file_path),
            "is_malicious": False,
            "confidence": 0.0,
            "error": None
        }
        
        try:
            img = self._preprocess_file(file_path)
            if img is None:
                result["error"] = "Invalid file content"
                return result
                
            pred = self.model.predict(np.expand_dims(img, axis=0))
            confidence = float(np.clip(pred[0][0], 0, 1))
            
            result.update({
                "is_malicious": confidence > 0.5,
                "confidence": confidence
            })
            
        except Exception as e:
            logger.error(f"Scan failed: {str(e)}")
            result["error"] = str(e)
            
        return result

    def scan_directory(self, directory_path: str) -> List[Dict[str, Any]]:
        """Scan all files in a directory"""
        results = []
        if not os.path.isdir(directory_path):
            return [{"error": f"Invalid directory: {directory_path}"}]
            
        for root, _, files in os.walk(directory_path):
            for file in files:
                file_path = os.path.join(root, file)
                results.append(self.scan_file(file_path))
                
        return results