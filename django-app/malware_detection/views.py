from rest_framework.decorators import api_view
from rest_framework.response import Response
from malware_detection.models import MalwareDetector
import logging, os, tempfile
import numpy as np
from PIL import Image
logger = logging.getLogger(__name__)

@api_view(['POST'])
def scan_file(request):
    try:
        if 'file' not in request.FILES:
            return Response({"error": "No file provided"}, status=400)
        
        uploaded_file = request.FILES['file']
        logger.info(f"Received file: {uploaded_file.name} ({uploaded_file.size} bytes)")
        
        # Save to temp file
        with tempfile.NamedTemporaryFile(delete=False) as tmp:
            for chunk in uploaded_file.chunks():
                tmp.write(chunk)
            tmp_path = tmp.name
        
        detector = MalwareDetector()
        result = detector.scan_file(tmp_path)
        
        # Clean up
        os.unlink(tmp_path)
        
        # Add original filename to results
        result['original_filename'] = uploaded_file.name
        result['temp_filename'] = os.path.basename(tmp_path)  # Optional: for debugging
        
        if 'confidence' in result and isinstance(result['confidence'], (float, int)):
            result['confidence'] = float(result['confidence'])
        
        return Response(result)
        
    except Exception as e:
        logger.error(f"Scan failed: {str(e)}", exc_info=True)
        return Response({"error": str(e)}, status=500)
    
@api_view(['GET'])
def count_files(request):
    """Count all scannable files in the filesystem"""
    try:
        EXCLUDED_DIRS = {'/proc', '/sys', '/dev', '/run', '/tmp', '/snap', '/boot'}
        count = 0
        
        for root, dirs, files in os.walk('/', topdown=True):
            # Skip excluded directories
            dirs[:] = [d for d in dirs if os.path.join(root, d) not in EXCLUDED_DIRS]
            
            for filename in files:
                filepath = os.path.join(root, filename)
                if _is_scannable(filepath):  # Reuse your existing scannable check
                    count += 1
        
        return Response({"total_files": count})
        
    except Exception as e:
        logger.error(f"File count failed: {str(e)}")
        return Response({"error": str(e)}, status=500)

@api_view(['POST'])
def scan_system(request):
    """Scan filesystem with safety checks, batch optimizations, and progress tracking"""
    try:
        # Configuration
        SCAN_PATH = request.data.get('path', '/')
        EXCLUDED_DIRS = {'/proc', '/sys', '/dev', '/run', '/tmp', '/snap', '/boot'}
        MAX_FILES = 10_000  # Prevent runaway scans
        BATCH_SIZE = 32  # For GPU-optimized batch predictions

        # Safety checks
        if not os.path.exists(SCAN_PATH):
            return Response({"error": f"Path does not exist: {SCAN_PATH}"}, status=400)
        if not os.access(SCAN_PATH, os.R_OK):
            return Response({"error": f"No read permissions: {SCAN_PATH}"}, status=403)

        detector = MalwareDetector()
        results = []
        file_batch = []
        scanned = 0
        malicious = 0

        for root, dirs, files in os.walk(SCAN_PATH, topdown=True):
            # Skip excluded directories
            dirs[:] = [d for d in dirs if os.path.join(root, d) not in EXCLUDED_DIRS]

            for filename in files:
                if scanned >= MAX_FILES:
                    logger.warning(f"Reached max file limit ({MAX_FILES})")
                    break

                filepath = os.path.join(root, filename)
                if not _is_scannable(filepath):
                    continue

                try:
                    with open(filepath, 'rb') as f:
                        file_batch.append((filepath, f.read()))
                    scanned += 1

                    # Process batch when full
                    if len(file_batch) >= BATCH_SIZE:
                        batch_results = _process_batch(detector, file_batch)
                        results.extend(batch_results)
                        malicious += sum(r['is_malicious'] for r in batch_results)
                        file_batch = []

                except Exception as e:
                    logger.error(f"Error reading {filepath}: {str(e)}")
                    results.append({"file": filepath, "error": str(e)})

        # Process remaining files
        if file_batch:
            batch_results = _process_batch(detector, file_batch)
            results.extend(batch_results)
            malicious += sum(r['is_malicious'] for r in batch_results)

        return Response({
            "scanned_path": SCAN_PATH,
            "scanned_files": scanned,
            "malicious_files": malicious,
            "sample_results": results[:100],  # Return subset for large scans
            "warning": "Truncated results" if len(results) > 100 else None
        })

    except Exception as e:
        logger.error(f"System scan crashed: {str(e)}", exc_info=True)
        return Response({"error": f"Scan failed: {str(e)}"}, status=500)

# --- Helper Functions ---
def _is_scannable(filepath):
    """Heuristic to skip non-executable files"""
    if not os.access(filepath, os.R_OK):
        return False
    
    # Skip based on extension
    ext = os.path.splitext(filepath)[1].lower()
    if ext in {'.txt', '.log', '.md', '.csv', '.json'}:
        return False
        
    # Check file headers (ELF, PE, Mach-O)
    with open(filepath, 'rb') as f:
        header = f.read(4)
        return header.startswith((b'\x7FELF', b'MZ', b'\xFE\xED\xFA\xCE'))

def _process_batch(detector, file_batch):
    """Process files in batches for better GPU utilization"""
    batch_results = []
    try:
        # Convert files to images in bulk
        images = []
        valid_files = []
        for filepath, content in file_batch:
            img = _bytes_to_image(content)
            if img is not None:
                images.append(img)
                valid_files.append(filepath)
        
        # Batch prediction
        if images:
            images = np.stack(images)
            predictions = detector.model.predict(images, batch_size=len(images))
            
            for i, (filepath, pred) in enumerate(zip(valid_files, predictions)):
                confidence = float(np.clip(pred[0], 0, 1))
                batch_results.append({
                    "file": filepath,
                    "is_malicious": confidence > 0.5,
                    "confidence": confidence,
                    "error": None
                })
                
    except Exception as e:
        logger.error(f"Batch processing failed: {str(e)}")
        # Fallback to individual scans
        for filepath, content in file_batch:
            try:
                result = detector.scan_file_bytes(content)
                result['file'] = filepath
                batch_results.append(result)
            except Exception as e:
                batch_results.append({"file": filepath, "error": str(e)})
    
    return batch_results

def _bytes_to_image(data):
    """Convert file bytes to model input format"""
    try:
        side = int(len(data)**0.5)
        img = Image.frombytes('L', (side, side), data[:side*side])
        img = img.resize((224, 224))
        img_array = np.array(img, dtype=np.float32) / 255.0
        return np.expand_dims(img_array, axis=-1)
    except Exception:
        return None